<!DOCTYPE html>
<html lang="zh-Hant">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1"
    />
    <title>工程白板拍照工具</title>
    <style>
      :root {
        --board-fill: #f8fafc;
        --text-color: #0f172a;
        --line-color: #000000;
        --board-rotation: 0deg;
        --board-scale-x: 0.45;
        --board-scale-y: 0.45;
        font-family: "Noto Sans TC", "Segoe UI", system-ui, -apple-system,
          BlinkMacSystemFont, sans-serif;
        line-height: 1.45;
        color: #0f172a;
        background: #0f172a;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        padding: 1.25rem;
        padding-bottom: calc(env(safe-area-inset-bottom, 0px) + 150px);
        background: radial-gradient(circle, #1e293b, #0f172a);
        display: flex;
        justify-content: center;
      }

      .app-shell {
        width: min(560px, 100%);
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }

      h1 {
        color: #f8fafc;
        text-align: center;
        margin: 0;
        font-size: clamp(1.4rem, 5vw, 2.1rem);
        letter-spacing: 0.08em;
      }

      .version-note {
        text-align: center;
        color: #facc15;
        font-size: 0.95rem;
        margin-top: 0.3rem;
        font-weight: 600;
      }

      .panel {
        background: rgba(15, 23, 42, 0.45);
        border-radius: 20px;
        padding: 1rem 1.1rem;
        border: 1px solid rgba(148, 163, 184, 0.35);
        color: #e2e8f0;
        backdrop-filter: blur(12px);
      }

      .panel h3 {
        margin: 0 0 0.75rem;
        font-size: 1.05rem;
        letter-spacing: 0.05em;
      }

      .data-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        gap: 0.75rem;
      }

      .form-field {
        display: flex;
        flex-direction: column;
        gap: 0.25rem;
      }

      .form-field label {
        font-size: 0.9rem;
      }

      .form-field input,
      .form-field textarea {
        border-radius: 12px;
        border: 1px solid rgba(226, 232, 240, 0.35);
        background: rgba(15, 23, 42, 0.6);
        color: #f8fafc;
        font: inherit;
        padding: 0.55rem 0.7rem;
      }

      .form-field textarea {
        min-height: 90px;
        resize: none;
        overflow: hidden;
      }

      .panel-hint {
        margin-top: 0.4rem;
        font-size: 0.83rem;
        color: #cbd5f5;
      }

      .panel-actions {
        margin-top: 0.8rem;
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        gap: 0.75rem;
        align-items: center;
      }

      .panel-control {
        display: flex;
        align-items: center;
        gap: 0.6rem;
      }

      .panel-control input[type="range"] {
        flex: 1;
      }

      .ghost-btn {
        border-radius: 999px;
        border: 1px solid rgba(226, 232, 240, 0.45);
        background: transparent;
        color: #e2e8f0;
        font-weight: 600;
        padding: 0.6rem 1.25rem;
        cursor: pointer;
      }

      .controls {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        gap: 0.75rem;
      }

      .btn {
        border: none;
        border-radius: 999px;
        padding: 0.75rem 1.1rem;
        font-weight: 700;
        font-size: 1rem;
        cursor: pointer;
        color: #fff;
        background: linear-gradient(135deg, #2563eb, #3b82f6);
        box-shadow: 0 10px 18px rgba(37, 99, 235, 0.3);
      }

      .btn-secondary {
        background: transparent;
        border: 2px solid #94a3b8;
        color: #e2e8f0;
        box-shadow: none;
      }

      .stage {
        position: relative;
        width: 100%;
        border-radius: 0;
        overflow: hidden;
        background: transparent;
        box-shadow: none;
        border: none;
        --stage-aspect: 56.25%;
      }

      .stage::before {
        content: "";
        display: block;
        padding-top: var(--stage-aspect);
      }

      .stage-content {
        position: absolute;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        background: transparent;
      }

      .stage-content.exporting {
        background: transparent;
      }

      .stage-content img {
        width: 100%;
        height: 100%;
        object-fit: contain;
      }

      .stage-placeholder {
        position: absolute;
        inset: 0;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 0.35rem;
        text-align: center;
        color: #cbd5f5;
      }

      .photo-watermark {
        position: absolute;
        right: clamp(0.35rem, 3vw, 0.85rem);
        bottom: clamp(0.3rem, 2.5vw, 0.75rem);
        color: #fbbf24;
        font-size: clamp(0.65rem, 2.5vw, 0.9rem);
        letter-spacing: 0.18em;
        font-weight: 800;
        -webkit-text-stroke: 0.5px rgba(0, 0, 0, 0.9);
        text-shadow: 0 1px 3px rgba(0, 0, 0, 0.45);
        pointer-events: none;
        z-index: 5;
      }

      .whiteboard-wrapper {
        --board-scale-x: clamp(0.35, calc(25vw / 100), 0.45);
        --board-scale-y: clamp(0.35, calc(25vw / 100), 0.45);
        --board-width: min(480px, 90%);
        position: absolute;
        left: 50%;
        top: 70%;
        transform: translate(-50%, -50%) rotate(var(--board-rotation))
          scale(var(--board-scale-x), var(--board-scale-y));
        transform-origin: center;
        width: var(--board-width);
        touch-action: none;
        transition: box-shadow 0.15s ease;
      }

      .whiteboard-wrapper.is-resizing {
        box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.4);
      }

      .resize-handle {
        position: absolute;
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: #38bdf8;
        border: 2px solid #fff;
        box-shadow: 0 0 6px rgba(0, 0, 0, 0.35);
        display: none;
        z-index: 10;
        touch-action: none;
      }

      .whiteboard-wrapper.show-handles .resize-handle {
        display: block;
      }

      .resize-handle[data-handle="top-left"] {
        top: -8px;
        left: -8px;
        cursor: nwse-resize;
      }

      .resize-handle[data-handle="top-right"] {
        top: -8px;
        right: -8px;
        cursor: nesw-resize;
      }

      .resize-handle[data-handle="bottom-right"] {
        bottom: -8px;
        right: -8px;
        cursor: nwse-resize;
      }

      .resize-handle[data-handle="bottom-left"] {
        bottom: -8px;
        left: -8px;
        cursor: nesw-resize;
      }
      .whiteboard {
        width: 100%;
        background: var(--board-fill);
        border-radius: 0;
        border: 4px solid var(--line-color);
        padding: 0.75rem;
        color: var(--text-color);
        box-shadow: none;
        font-weight: 700;
      }

      .whiteboard.exporting {
        box-shadow: none;
      }

      .whiteboard-content {
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
      }

      .board-row {
        display: flex;
        align-items: center;
        gap: 0.2rem;
      }

      .board-row label {
        flex: 0 0 72px;
        font-size: 0.86rem;
        letter-spacing: 0.03em;
        color: var(--text-color);
        position: relative;
        padding-right: 0.2rem;
      }

      .board-row label::after {
        content: "：";
        position: absolute;
        right: 0;
      }

      .board-block label::after {
        content: "：";
      }

      .board-value {
        flex: 1;
        min-height: 34px;
        border: 1px solid var(--line-color);
        border-radius: 10px;
        padding: 0.35rem 0.55rem;
        background: var(--board-fill);
        font-size: 0.96rem;
        font-weight: 600;
        color: var(--text-color);
        white-space: pre-wrap;
      }

      .board-block {
        display: flex;
        flex-direction: column;
        gap: 0.25rem;
      }

      .board-block label {
        font-size: 0.88rem;
        letter-spacing: 0.04em;
        color: var(--text-color);
      }

      .board-notes {
        min-height: 3.2rem;
        border: 1px solid var(--line-color);
        border-radius: 14px;
        padding: 0.65rem 0.75rem;
        background: var(--board-fill);
        font-size: 1rem;
        line-height: 1.4;
        color: var(--text-color);
        white-space: pre-wrap;
      }

      .signature-placeholder-box {
        flex: 1;
        min-height: 80px;
        border: 1px dashed var(--line-color);
        border-radius: 12px;
        background: var(--board-fill);
        display: flex;
        align-items: center;
        justify-content: center;
        color: var(--text-color);
        font-size: 0.95rem;
      }

      .action-bar {
        position: fixed;
        bottom: calc(env(safe-area-inset-bottom, 0px) + 12px);
        left: 50%;
        transform: translateX(-50%);
        width: min(520px, calc(100% - 1.5rem));
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 0.75rem;
        padding: 0.85rem 1rem;
        border-radius: 24px;
        background: rgba(15, 23, 42, 0.85);
        box-shadow: 0 20px 35px rgba(0, 0, 0, 0.45);
        backdrop-filter: blur(12px);
      }

      .action-btn {
        border: none;
        border-radius: 999px;
        padding: 0.85rem 1.25rem;
        font-weight: 700;
        font-size: 1rem;
        cursor: pointer;
      }

      .action-btn.primary {
        background: linear-gradient(135deg, #059669, #10b981);
        color: #fff;
      }

      .action-btn.secondary {
        background: rgba(255, 255, 255, 0.08);
        color: #f8fafc;
        border: 1px solid rgba(255, 255, 255, 0.2);
      }

      .toast-message {
        position: fixed;
        bottom: calc(env(safe-area-inset-bottom, 0px) + 90px);
        left: 50%;
        transform: translateX(-50%);
        width: min(520px, calc(100% - 1.5rem));
        padding: 0.75rem 1rem;
        border-radius: 16px;
        background: rgba(15, 23, 42, 0.9);
        color: #f8fafc;
        text-align: center;
        font-size: 0.95rem;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.3s ease, transform 0.3s ease;
      }

      .toast-message.visible {
        opacity: 1;
        transform: translateX(-50%) translateY(-8px);
      }

      .toast-message[data-variant="success"] {
        background: rgba(34, 197, 94, 0.9);
        color: #052e13;
      }

      .hidden-input {
        display: none !important;
      }
    </style>
  </head>
  <body>
    <div class="app-shell">

      <section class="panel">
        <h3>資料輸入面板</h3>
        <div class="data-grid">
          <div class="form-field">
            <label for="inputProjectName">工程名稱</label>
            <input id="inputProjectName" type="text" placeholder="請輸入工程名稱" />
          </div>
          <div class="form-field">
            <label for="inputInspectionLocation">檢查位置</label>
            <input id="inputInspectionLocation" type="text" placeholder="請輸入檢查位置" />
          </div>
          <div class="form-field">
            <label for="inputTestDate">檢查日期</label>
            <input id="inputTestDate" type="date" />
          </div>
          <div class="form-field">
            <label for="inputInspector">檢查人員</label>
            <input id="inputInspector" type="text" placeholder="請輸入檢查人員" />
          </div>
          <div class="form-field" style="grid-column: 1 / -1">
            <label for="inputTestResult">檢查紀錄</label>
            <textarea id="inputTestResult" placeholder="寫下檢查內容、測量結果等"></textarea>
          </div>
        </div>
        <div class="panel-hint">輸入完畢後按下「套用到白板」。</div>
        <div class="panel-actions">
          <label class="panel-control">
            <span>白板尺寸</span>
            <input type="range" id="boardScale" min="10" max="120" value="45" />
            <span id="boardScaleValue">45%</span>
          </label>
          <label class="panel-control">
            <span>白板寬度</span>
            <input type="range" id="boardWidth" min="240" max="640" value="480" />
            <span id="boardWidthValue">480px</span>
          </label>
          <label class="panel-control">
            <span>白板傾斜</span>
            <input type="range" id="boardRotation" min="-20" max="20" value="0" />
            <span id="boardRotationValue">0°</span>
          </label>
          <label class="panel-control">
            <span>白板顏色</span>
            <input type="color" id="boardColor" value="#f8fafc" />
          </label>
          <label class="panel-control">
            <span>透明度</span>
            <input type="range" id="boardOpacity" min="70" max="100" value="96" />
            <span id="boardOpacityValue">96%</span>
          </label>
          <label class="panel-control">
            <span>文字顏色</span>
            <input type="color" id="textColor" value="#0f172a" />
          </label>
          <label class="panel-control">
            <span>格線顏色</span>
            <input type="color" id="lineColor" value="#000000" />
          </label>
          <button type="button" class="ghost-btn" id="applyDataBtn">套用到白板</button>
        </div>
      </section>

      <div class="controls">
        <button class="btn" id="takePhotoBtn">拍照</button>
        <button class="btn btn-secondary" id="uploadPhotoBtn">上傳照片</button>
      </div>

      <div class="stage" id="captureArea">
        <div class="stage-content" id="photoLayer">
          <img id="photoImage" alt="拍攝預覽" hidden />
          <div class="stage-placeholder" id="placeholder">
            <strong>請拍照或上傳照片</strong>
            <span>白板會顯示在畫面上，可拖曳與縮放。</span>
          </div>
        </div>
        <div class="whiteboard-wrapper" id="whiteboardWrapper">
          <button class="resize-handle" data-handle="top-left" type="button" aria-label="調整白板 左上"></button>
          <button class="resize-handle" data-handle="top-right" type="button" aria-label="調整白板 右上"></button>
          <button class="resize-handle" data-handle="bottom-right" type="button" aria-label="調整白板 右下"></button>
          <button class="resize-handle" data-handle="bottom-left" type="button" aria-label="調整白板 左下"></button>
          <div class="whiteboard" id="whiteboard">
            <div class="whiteboard-content">
              <div class="board-row">
                <label>工程名稱</label>
                <div class="board-value" id="displayProjectName">—</div>
              </div>
              <div class="board-row">
                <label>檢查位置</label>
                <div class="board-value" id="displayInspectionLocation">—</div>
              </div>
              <div class="board-block">
                <label>檢查紀錄</label>
                <div class="board-notes" id="displayTestResult">—</div>
              </div>
              <div class="board-row">
                <label>檢查日期</label>
                <div class="board-value" id="displayTestDate">—</div>
              </div>
              <div class="board-row">
                <label>檢查人員</label>
                <div class="board-value" id="displayInspector">—</div>
              </div>
            </div>
          </div>
        </div>
        <div class="photo-watermark" id="photoWatermark">日期未設定</div>
      </div>

      <div class="action-bar">
        <button class="action-btn secondary" id="clearBoardBtn">清除白板</button>
        <button class="action-btn primary" id="exportBtn">匯出整張圖片</button>
      </div>

      <p id="toastMessage" class="toast-message" role="status" aria-live="polite"></p>

      <input type="file" accept="image/*" capture="environment" class="hidden-input" id="takePhotoInput" />
      <input type="file" accept="image/*" class="hidden-input" id="uploadInput" />
    </div>

    <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
    <script>
      const takePhotoBtn = document.getElementById("takePhotoBtn");
      const uploadPhotoBtn = document.getElementById("uploadPhotoBtn");
      const takePhotoInput = document.getElementById("takePhotoInput");
      const uploadInput = document.getElementById("uploadInput");
      const photoLayer = document.getElementById("photoLayer");
      const photoImage = document.getElementById("photoImage");
      const placeholder = document.getElementById("placeholder");
      const whiteboardWrapper = document.getElementById("whiteboardWrapper");
      const whiteboard = document.getElementById("whiteboard");
      const captureArea = document.getElementById("captureArea");
      const boardScaleInput = document.getElementById("boardScale");
      const boardScaleValue = document.getElementById("boardScaleValue");
      const resizeHandles = document.querySelectorAll(".resize-handle");
      const boardWidthInput = document.getElementById("boardWidth");
      const boardWidthValue = document.getElementById("boardWidthValue");
      const boardRotationInput = document.getElementById("boardRotation");
      const boardRotationValue = document.getElementById("boardRotationValue");
      const boardColorInput = document.getElementById("boardColor");
      const boardOpacityInput = document.getElementById("boardOpacity");
      const boardOpacityValue = document.getElementById("boardOpacityValue");
      const textColorInput = document.getElementById("textColor");
      const lineColorInput = document.getElementById("lineColor");
      const applyDataBtn = document.getElementById("applyDataBtn");
      const clearBoardBtn = document.getElementById("clearBoardBtn");
      const exportBtn = document.getElementById("exportBtn");
      const toastMessage = document.getElementById("toastMessage");
      const photoWatermark = document.getElementById("photoWatermark");
      whiteboardWrapper.dataset.userPositioned = "false";
      let boardScaleBase = Number(boardScaleInput.value) / 100;
      let boardStretchX = 1;
      let boardStretchY = 1;

      const isMobileDevice = /android|iphone|ipad|ipod|mobile/i.test(
        (navigator.userAgent || "").toLowerCase()
      );

      const formInputs = {
        projectName: document.getElementById("inputProjectName"),
        inspectionLocation: document.getElementById("inputInspectionLocation"),
        testResult: document.getElementById("inputTestResult"),
        testDate: document.getElementById("inputTestDate"),
        inspector: document.getElementById("inputInspector"),
      };

      const displayTargets = {
        projectName: document.getElementById("displayProjectName"),
        inspectionLocation: document.getElementById("displayInspectionLocation"),
        testResult: document.getElementById("displayTestResult"),
        testDate: document.getElementById("displayTestDate"),
        inspector: document.getElementById("displayInspector"),
      };

      const formatWatermarkDate = (value) => {
        if (!value) return "日期未設定";
        const [year, month, day] = value.split("-");
        if (!year || !month || !day) return value;
        return `${year}/${month}/${day}`;
      };

      const updateWatermarkDate = () => {
        if (!photoWatermark) return;
        photoWatermark.textContent = formatWatermarkDate(formInputs.testDate.value);
      };

      const formatDateInputValue = (date) => {
        if (!(date instanceof Date) || Number.isNaN(date.getTime())) return "";
        const month = String(date.getMonth() + 1).padStart(2, "0");
        const day = String(date.getDate()).padStart(2, "0");
        return `${date.getFullYear()}-${month}-${day}`;
      };

      const readFileAsDataURL = (file) =>
        new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = () => resolve(reader.result);
          reader.onerror = () => reject(new Error("failed to load file"));
          reader.readAsDataURL(file);
        });

      const asciiFromView = (view, start, length) => {
        let chars = "";
        for (let i = 0; i < length && start + i < view.byteLength; i += 1) {
          const code = view.getUint8(start + i);
          if (!code) break;
          chars += String.fromCharCode(code);
        }
        return chars;
      };

      const normalizeExifDate = (value) => {
        if (!value) return null;
        const match = value.match(/^(\d{4}):?(\d{2}):?(\d{2})/);
        if (!match) return null;
        const [, year, month, day] = match;
        return `${year}-${month}-${day}`;
      };

      const TYPE_SIZES = {
        1: 1,
        2: 1,
        3: 2,
        4: 4,
        5: 8,
        7: 1,
      };

      const EXIF_DATE_TAGS = new Set([0x0132, 0x9003, 0x9004]);

      const parseIfdForDate = (view, offset, base, little) => {
        if (offset <= 0 || offset + 2 > view.byteLength) return null;
        const entryCount = view.getUint16(offset, little);
        let exifPointer = null;
        let fallbackDate = null;
        for (let i = 0; i < entryCount; i += 1) {
          const entryOffset = offset + 2 + i * 12;
          if (entryOffset + 12 > view.byteLength) break;
          const tag = view.getUint16(entryOffset, little);
          const type = view.getUint16(entryOffset + 2, little);
          const count = view.getUint32(entryOffset + 4, little);
          const valueSize = (TYPE_SIZES[type] || 0) * count;
          const rawValueOffset = entryOffset + 8;
          let valueOffset = rawValueOffset;
          if (valueSize > 4) {
            valueOffset = base + view.getUint32(rawValueOffset, little);
          }
          if (tag === 0x8769) {
            exifPointer = base + view.getUint32(rawValueOffset, little);
            continue;
          }
          if (EXIF_DATE_TAGS.has(tag) && type === 2 && count > 0) {
            const raw = asciiFromView(view, valueOffset, count);
            const normalized = normalizeExifDate(raw);
            if (normalized) {
              if (tag === 0x9003) return normalized;
              fallbackDate = fallbackDate || normalized;
            }
          }
        }
        if (exifPointer) {
          const nestedDate = parseIfdForDate(view, exifPointer, base, little);
          if (nestedDate) return nestedDate;
        }
        return fallbackDate;
      };

      const readExifDateFromBuffer = (buffer) => {
        const view = new DataView(buffer);
        if (view.byteLength < 12 || view.getUint16(0, false) !== 0xffd8) return null;
        let offset = 2;
        while (offset + 4 < view.byteLength) {
          if (view.getUint8(offset) !== 0xff) break;
          const marker = view.getUint8(offset + 1);
          const length = view.getUint16(offset + 2, false);
          if (marker === 0xe1) {
            const segmentStart = offset + 4;
            const identifier = asciiFromView(view, segmentStart, 4);
            if (identifier !== "Exif") {
              offset += 2 + length;
              continue;
            }
            const tiffStart = segmentStart + 6;
            if (tiffStart + 8 > view.byteLength) break;
            const little = view.getUint16(tiffStart, false) === 0x4949;
            const firstIfdOffset = view.getUint32(tiffStart + 4, little);
            return parseIfdForDate(view, tiffStart + firstIfdOffset, tiffStart, little);
          }
          offset += 2 + length;
        }
        return null;
      };

      const extractExifDate = async (file) => {
        if (!file || !/image\/jpe?g/i.test(file.type || "")) return null;
        try {
          const buffer = await file.arrayBuffer();
          return readExifDateFromBuffer(buffer);
        } catch {
          return null;
        }
      };

      const applyPhotoDateMetadata = async (file) => {
        if (!file) return;
        let resolvedDate = null;
        let usedExif = false;
        try {
          const exifDate = await extractExifDate(file);
          if (exifDate) {
            resolvedDate = exifDate;
            usedExif = true;
          }
        } catch (error) {
          console.warn("EXIF 解析失敗", error);
        }

        if (!resolvedDate) {
          resolvedDate =
            file.lastModified && Number.isFinite(file.lastModified)
              ? formatDateInputValue(new Date(file.lastModified))
              : formatDateInputValue(new Date());
        }

        formInputs.testDate.value = resolvedDate;
        syncField("testDate");
        showToast(
          usedExif ? "已套用照片拍攝日期，如需修改可手動調整。" : "已套用拍攝日期，如需修改可手動調整。",
          "success"
        );
      };

      const autoResizeTextarea = (textarea) => {
        if (!textarea) return;
        textarea.style.height = "auto";
        textarea.style.height = `${Math.min(textarea.scrollHeight, 600)}px`;
      };

      const showToast = (message, variant = "info") => {
        toastMessage.textContent = message;
        toastMessage.dataset.variant = variant;
        toastMessage.classList.add("visible");
        clearTimeout(showToast.timer);
        showToast.timer = setTimeout(
          () => toastMessage.classList.remove("visible"),
          4500
        );
      };

      const updateStageAspect = () => {
        if (photoImage.hidden || !photoImage.naturalWidth) {
          captureArea.style.setProperty("--stage-aspect", "56.25%");
          requestAnimationFrame(positionBoardAtBottomLeft);
          return;
        }
        const ratio = (photoImage.naturalHeight / photoImage.naturalWidth) * 100;
        captureArea.style.setProperty("--stage-aspect", `${ratio}%`);
        requestAnimationFrame(positionBoardAtBottomLeft);
      };

      const handlePhotoFiles = async (files) => {
        const [file] = files || [];
        if (!file) return;
        try {
        const dataUrl = await readFileAsDataURL(file);
        photoImage.src = dataUrl;
        photoImage.hidden = false;
        placeholder.style.display = "none";
        updateStageAspect();
        whiteboardWrapper.dataset.userPositioned = "false";
        requestAnimationFrame(positionBoardAtBottomLeft);
        } catch (error) {
          showToast("照片載入失敗，請重新選擇。");
          return;
        }
        await applyPhotoDateMetadata(file);
      };

      const clamp = (value, min, max) => Math.min(Math.max(value, min), max);

      const applyBoardScale = () => {
        const scaleX = boardScaleBase * boardStretchX;
        const scaleY = boardScaleBase * boardStretchY;
        whiteboardWrapper.style.setProperty("--board-scale-x", scaleX.toString());
        whiteboardWrapper.style.setProperty("--board-scale-y", scaleY.toString());
        boardScaleValue.textContent = `${Math.round(boardScaleBase * 100)}%`;
      };

      const startDrag = (event) => {
        if (event.target.closest("input, textarea, button, select")) return;
        whiteboardWrapper.dataset.dragging = "true";
        whiteboardWrapper.dataset.userPositioned = "true";
        const rect = whiteboardWrapper.getBoundingClientRect();
        whiteboardWrapper.dataset.offsetX =
          (event.clientX ?? event.touches?.[0]?.clientX ?? 0) - rect.left;
        whiteboardWrapper.dataset.offsetY =
          (event.clientY ?? event.touches?.[0]?.clientY ?? 0) - rect.top;
        whiteboardWrapper.dataset.stageRect = JSON.stringify(
          captureArea.getBoundingClientRect()
        );
      };

      const dragMove = (event) => {
        if (whiteboardWrapper.dataset.dragging !== "true") return;
        event.preventDefault();
        const stageRect = JSON.parse(whiteboardWrapper.dataset.stageRect);
        const boardRect = whiteboardWrapper.getBoundingClientRect();
        const offsetX = parseFloat(whiteboardWrapper.dataset.offsetX);
        const offsetY = parseFloat(whiteboardWrapper.dataset.offsetY);
        const pointerX = event.clientX ?? event.touches?.[0]?.clientX ?? 0;
        const pointerY = event.clientY ?? event.touches?.[0]?.clientY ?? 0;
        const newLeft = clamp(
          pointerX - stageRect.left - offsetX + boardRect.width / 2,
          boardRect.width / 2,
          stageRect.width - boardRect.width / 2
        );
        const newTop = clamp(
          pointerY - stageRect.top - offsetY + boardRect.height / 2,
          boardRect.height / 2,
          stageRect.height - boardRect.height / 2
        );
        whiteboardWrapper.style.left = `${(newLeft / stageRect.width) * 100}%`;
        whiteboardWrapper.style.top = `${(newTop / stageRect.height) * 100}%`;
      };

      const endDrag = () => {
        whiteboardWrapper.dataset.dragging = "false";
      };

      const positionBoardAtBottomLeft = () => {
        if (whiteboardWrapper.dataset.userPositioned === "true") return;
        const stageRect = captureArea.getBoundingClientRect();
        if (!stageRect.width || !stageRect.height) return;
        const boardRect = whiteboardWrapper.getBoundingClientRect();
        if (!boardRect.width || !boardRect.height) return;
        const photoRect =
          !photoImage.hidden && photoImage.naturalWidth
            ? photoImage.getBoundingClientRect()
            : stageRect;
        const paddingX = Math.max(8, stageRect.width * 0.012);
        const paddingY = Math.max(8, stageRect.height * 0.012);
        const leftEdge = Math.max(photoRect.left, stageRect.left) + paddingX;
        const bottomEdge = Math.min(photoRect.bottom, stageRect.bottom) - paddingY;
        const centerX = clamp(
          leftEdge - stageRect.left + boardRect.width / 2,
          boardRect.width / 2,
          stageRect.width - boardRect.width / 2
        );
        const centerY = clamp(
          bottomEdge - stageRect.top - boardRect.height / 2,
          boardRect.height / 2,
          stageRect.height - boardRect.height / 2
        );
        whiteboardWrapper.style.left = `${(centerX / stageRect.width) * 100}%`;
        whiteboardWrapper.style.top = `${(centerY / stageRect.height) * 100}%`;
      };

      const updateBoardScale = (value) => {
        const percent = Math.max(10, Math.min(120, Number(value)));
        boardScaleBase = percent / 100;
        applyBoardScale();
        if (whiteboardWrapper.dataset.userPositioned !== "true") {
          requestAnimationFrame(positionBoardAtBottomLeft);
        }
      };

      const RESIZE_DIRECTIONS = {
        "top-left": { x: -1, y: -1 },
        "top-right": { x: 1, y: -1 },
        "bottom-right": { x: 1, y: 1 },
        "bottom-left": { x: -1, y: 1 },
      };

      let handleHideTimer = null;
      const showHandles = () => {
        whiteboardWrapper.classList.add("show-handles");
        clearTimeout(handleHideTimer);
      };
      const hideHandles = () => {
        if (whiteboardWrapper.dataset.resizingHandle) return;
        clearTimeout(handleHideTimer);
        handleHideTimer = setTimeout(
          () => whiteboardWrapper.classList.remove("show-handles"),
          800
        );
      };

      const startHandleResize = (handle, event) => {
        const dir = RESIZE_DIRECTIONS[handle];
        if (!dir) return;
        event.preventDefault();
        event.stopPropagation();
        whiteboardWrapper.dataset.userPositioned = "true";
        whiteboardWrapper.classList.add("is-resizing");
        whiteboardWrapper.dataset.resizingHandle = handle;
        whiteboardWrapper.dataset.startPointerX =
          event.clientX ?? event.touches?.[0]?.clientX ?? 0;
        whiteboardWrapper.dataset.startPointerY =
          event.clientY ?? event.touches?.[0]?.clientY ?? 0;
        whiteboardWrapper.dataset.stretchX = boardStretchX.toString();
        whiteboardWrapper.dataset.stretchY = boardStretchY.toString();
      };

      const handleResizeMove = (event) => {
        const handle = whiteboardWrapper.dataset.resizingHandle;
        if (!handle) return;
        const dir = RESIZE_DIRECTIONS[handle];
        if (!dir) return;
        event.preventDefault();
        const startX = parseFloat(whiteboardWrapper.dataset.startPointerX);
        const startY = parseFloat(whiteboardWrapper.dataset.startPointerY);
        const pointerX = event.clientX ?? event.touches?.[0]?.clientX ?? 0;
        const pointerY = event.clientY ?? event.touches?.[0]?.clientY ?? 0;
        const deltaX = ((pointerX - startX) / captureArea.offsetWidth) * dir.x;
        const deltaY = ((pointerY - startY) / captureArea.offsetHeight) * dir.y;
        const baseStretchX = parseFloat(whiteboardWrapper.dataset.stretchX) || 1;
        const baseStretchY = parseFloat(whiteboardWrapper.dataset.stretchY) || 1;
        boardStretchX = clamp(baseStretchX * (1 + deltaX), 0.4, 2.5);
        boardStretchY = clamp(baseStretchY * (1 + deltaY), 0.4, 2.5);
        applyBoardScale();
      };

      const endHandleResize = () => {
        whiteboardWrapper.classList.remove("is-resizing");
        delete whiteboardWrapper.dataset.resizingHandle;
      };

      const updateBoardWidth = (value) => {
        const width = Math.max(200, Math.min(800, Number(value)));
        const clamped = Math.round(width);
        whiteboardWrapper.style.setProperty("--board-width", `${clamped}px`);
        boardWidthValue.textContent = `${clamped}px`;
        if (whiteboardWrapper.dataset.userPositioned !== "true") {
          requestAnimationFrame(positionBoardAtBottomLeft);
        }
      };

      const toggleExportAppearance = (enable) => {
        const state = Boolean(enable);
        captureArea.classList.toggle("exporting", state);
        photoLayer.classList.toggle("exporting", state);
        whiteboard.classList.toggle("exporting", state);
      };

      function syncField(key) {
        const value = formInputs[key].value.trim();
        displayTargets[key].textContent = value || "—";
        if (key === "testDate") {
          updateWatermarkDate();
        }
      }

      const syncAllFields = () => Object.keys(formInputs).forEach(syncField);

      const clearBoard = () => {
        Object.values(formInputs).forEach((input) => (input.value = ""));
        formInputs.testDate.valueAsDate = new Date();
        syncAllFields();
      };

      const updateBoardColor = (color) => {
        document.documentElement.style.setProperty("--board-fill", color);
      };

      const updateBoardRotation = (value) => {
        const angle = Math.max(-90, Math.min(90, Number(value)));
        document.documentElement.style.setProperty("--board-rotation", `${angle}deg`);
        boardRotationValue.textContent = `${angle}°`;
      };

      const updateBoardOpacity = (percent) => {
        const value = Math.max(30, Math.min(100, Number(percent)));
        whiteboard.style.opacity = (value / 100).toString();
        boardOpacityValue.textContent = `${value}%`;
      };

      const updateTextColor = (color) => {
        document.documentElement.style.setProperty("--text-color", color);
      };

      const updateLineColor = (color) => {
        document.documentElement.style.setProperty("--line-color", color);
      };

      const toggleWhiteboardSolid = (enable) => {
        whiteboard.classList.toggle("solid-mode", Boolean(enable));
      };

      const downloadBlob = (blob, filename) => {
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.href = url;
        link.download = filename;
        link.click();
        setTimeout(() => URL.revokeObjectURL(url), 2000);
      };

      const buildShareText = () => {
        const sections = [
          { label: "檢查位置", value: displayTargets.inspectionLocation.textContent },
          { label: "檢查日期", value: displayTargets.testDate.textContent },
        ];
        return sections.map((item) => `${item.label}：${item.value || "—"}`).join("\n");
      };

      const handleShareOrDownload = async (blob, filename) => {
        const file = new File([blob], filename, { type: "image/jpeg" });
        const shareText = buildShareText();
        if (
          isMobileDevice &&
          navigator.canShare &&
          navigator.canShare({ files: [file] }) &&
          navigator.share
        ) {
          try {
            await navigator.share({
              files: [file],
              title: "工程白板照片",
              text: shareText,
            });
            showToast("已開啟分享面板，請選擇儲存影像。", "success");
            return;
          } catch (error) {
            if (error.name !== "AbortError") {
              showToast("分享面板不可用，將自動下載影像。");
            }
          }
        }
        downloadBlob(blob, filename);
        showToast("已下載圖片，可直接選擇儲存位置。", "success");
      };

      const exportBoardImage = async () => {
        exportBtn.disabled = true;
        exportBtn.textContent = "匯出中…";
        toggleExportAppearance(true);
        toggleWhiteboardSolid(true);
        try {
          const canvas = await html2canvas(captureArea, {
            backgroundColor: null,
            scale: window.devicePixelRatio || 2,
          });
          const blob = await new Promise((resolve, reject) =>
            canvas.toBlob((b) => (b ? resolve(b) : reject(new Error("failed"))), "image/jpeg", 0.92)
          );
          const timestamp = new Date().toISOString().replace(/[T:]/g, "-").split(".")[0];
          await handleShareOrDownload(blob, `whiteboard_${timestamp}.jpg`);
        } catch (error) {
          console.error(error);
          showToast("匯出失敗，請再試一次。");
        } finally {
          toggleExportAppearance(false);
          toggleWhiteboardSolid(false);
          exportBtn.disabled = false;
          exportBtn.textContent = "匯出整張圖片";
        }
      };

      takePhotoBtn.addEventListener("click", () => takePhotoInput.click());
      uploadPhotoBtn.addEventListener("click", () => uploadInput.click());
      takePhotoInput.addEventListener("change", (event) => handlePhotoFiles(event.target.files));
      uploadInput.addEventListener("change", (event) => handlePhotoFiles(event.target.files));

      whiteboardWrapper.addEventListener("pointerdown", startDrag);
      window.addEventListener("pointermove", dragMove, { passive: false });
      window.addEventListener("pointerup", endDrag);
      window.addEventListener("pointercancel", endDrag);

      applyDataBtn.addEventListener("click", () => {
        syncAllFields();
        showToast("白板內容已更新。", "success");
      });

      clearBoardBtn.addEventListener("click", () => {
        clearBoard();
        showToast("白板文字已清除。", "success");
      });

      boardScaleInput.addEventListener("input", (event) =>
        updateBoardScale(event.target.value)
      );
      resizeHandles.forEach((handle) => {
        ["pointerdown", "touchstart"].forEach((type) =>
          handle.addEventListener(type, (event) =>
            startHandleResize(handle.dataset.handle, event)
          )
        );
      });
      ["pointerenter", "touchstart"].forEach((type) =>
        whiteboardWrapper.addEventListener(type, showHandles, { passive: true })
      );
      ["pointerleave"].forEach((type) =>
        whiteboardWrapper.addEventListener(type, hideHandles)
      );
      window.addEventListener("pointermove", handleResizeMove, { passive: false });
      window.addEventListener("touchmove", handleResizeMove, { passive: false });
      window.addEventListener("pointerup", endHandleResize);
      window.addEventListener("pointercancel", endHandleResize);
      window.addEventListener("touchend", endHandleResize);
      boardWidthInput.addEventListener("input", (event) =>
        updateBoardWidth(event.target.value)
      );
      boardRotationInput.addEventListener("input", (event) =>
        updateBoardRotation(event.target.value)
      );
      boardColorInput.addEventListener("input", (event) =>
        updateBoardColor(event.target.value)
      );
      boardOpacityInput.addEventListener("input", (event) =>
        updateBoardOpacity(event.target.value)
      );
      textColorInput.addEventListener("input", (event) =>
        updateTextColor(event.target.value)
      );
      lineColorInput.addEventListener("input", (event) =>
        updateLineColor(event.target.value)
      );

      exportBtn.addEventListener("click", exportBoardImage);
      window.addEventListener("resize", updateStageAspect);
      photoImage.addEventListener("load", updateStageAspect);

      if (isMobileDevice) {
        boardScaleInput.value = "35";
        boardScaleBase = 0.35;
        boardScaleValue.textContent = "35%";
        applyBoardScale();
      }
      if (!formInputs.testDate.value) {
        formInputs.testDate.valueAsDate = new Date();
      }
      syncAllFields();
      updateBoardScale(boardScaleInput.value);
      updateBoardWidth(boardWidthInput.value);
      updateBoardRotation(boardRotationInput.value);
      updateBoardColor(boardColorInput.value);
      updateBoardOpacity(boardOpacityInput.value);
      updateTextColor(textColorInput.value);
      updateLineColor(lineColorInput.value);
      updateWatermarkDate();
      requestAnimationFrame(positionBoardAtBottomLeft);
      autoResizeTextarea(formInputs.testResult);
      formInputs.testResult.addEventListener("input", () =>
        autoResizeTextarea(formInputs.testResult)
      );
      formInputs.testDate.addEventListener("change", () =>
        syncField("testDate")
      );
    </script>
  </body>
</html>

