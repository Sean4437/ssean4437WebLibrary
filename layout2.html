<!DOCTYPE html>
<html lang="zh-Hant">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1"
    />
    <title>麗鄴電子白板-布局3</title>
    <style>
      :root {
        --board-fill: #f8fafc;
        --text-color: #0f172a;
        --line-color: #000000;
        --board-rotation: 0deg;
        font-family: "Noto Sans TC", "Segoe UI", system-ui, -apple-system,
          BlinkMacSystemFont, sans-serif;
        line-height: 1.45;
        color: #0f172a;
        background: #0f172a;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        padding: 1.25rem;
        padding-bottom: calc(env(safe-area-inset-bottom, 0px) + 150px);
        background: radial-gradient(circle, #1e293b, #0f172a);
        display: flex;
        justify-content: center;
      }

      .app-shell {
        width: min(560px, 100%);
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }

      h1 {
        color: #f8fafc;
        text-align: center;
        margin: 0;
        font-size: clamp(1.4rem, 5vw, 2.1rem);
        letter-spacing: 0.08em;
      }

      .version-note {
        text-align: center;
        color: #facc15;
        font-size: 0.95rem;
        margin-top: 0.3rem;
        font-weight: 600;
      }

      .panel {
        background: rgba(15, 23, 42, 0.45);
        border-radius: 20px;
        padding: 1rem 1.1rem;
        border: 1px solid rgba(148, 163, 184, 0.35);
        color: #e2e8f0;
        backdrop-filter: blur(12px);
      }

      .panel h3 {
        margin: 0 0 0.75rem;
        font-size: 1.05rem;
        letter-spacing: 0.05em;
      }

      .data-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        gap: 0.75rem;
      }

      .form-field {
        display: flex;
        flex-direction: column;
        gap: 0.25rem;
      }

      .form-field label {
        font-size: 0.9rem;
      }

      .form-field input,
      .form-field textarea {
        border-radius: 12px;
        border: 1px solid rgba(226, 232, 240, 0.35);
        background: rgba(15, 23, 42, 0.6);
        color: #f8fafc;
        font: inherit;
        padding: 0.55rem 0.7rem;
      }

      .form-field textarea {
        min-height: 90px;
        resize: none;
        overflow: hidden;
      }

      .history-dropdown {
        margin-top: 0.4rem;
        border: 1px solid rgba(148, 163, 184, 0.4);
        border-radius: 12px;
        background: rgba(15, 23, 42, 0.9);
        box-shadow: 0 12px 24px rgba(15, 23, 42, 0.4);
        max-height: 200px;
        overflow-y: auto;
        display: none;
        flex-direction: column;
        gap: 0.25rem;
        padding: 0.4rem;
      }

      .history-dropdown.is-visible {
        display: flex;
      }

      .history-dropdown button {
        border: 1px solid rgba(148, 163, 184, 0.35);
        border-radius: 8px;
        padding: 0.4rem 0.55rem;
        background: rgba(15, 23, 42, 0.65);
        color: #e2e8f0;
        font: inherit;
        text-align: left;
        cursor: pointer;
        transition: border-color 0.2s ease, background 0.2s ease;
      }

      .history-dropdown button:hover,
      .history-dropdown button:focus-visible {
        border-color: #38bdf8;
        background: rgba(56, 189, 248, 0.2);
        outline: none;
      }

      .panel-hint {
        margin-top: 0.4rem;
        font-size: 0.83rem;
        color: #cbd5f5;
      }

      .panel-actions {
        margin-top: 0.8rem;
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        gap: 0.75rem;
        align-items: center;
      }

      .color-preset-group {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
        grid-column: 1 / -1;
      }

      .color-swatch {
        width: 46px;
        height: 28px;
        border-radius: 14px;
        border: 2px solid rgba(255, 255, 255, 0.2);
        background: transparent;
        position: relative;
        cursor: pointer;
        transition: transform 0.15s ease, border-color 0.2s ease;
        padding: 0;
      }

      .color-swatch::before {
        content: "";
        position: absolute;
        inset: 5px 8px 5px 8px;
        border-radius: 10px;
        background: var(--swatch-color, #fff);
        box-shadow: inset 0 0 0 1px rgba(15, 23, 42, 0.25);
      }

      .color-swatch:hover,
      .color-swatch:focus-visible {
        border-color: #38bdf8;
        outline: none;
        transform: translateY(-1px);
      }

      .sr-only {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
      }

      .toggle-advanced {
        margin-top: 0.6rem;
        width: 100%;
      }

      .advanced-controls {
        margin-top: 0.5rem;
        border-top: 1px dashed rgba(148, 163, 184, 0.4);
        padding-top: 0.6rem;
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        gap: 0.75rem;
      }

      .advanced-controls[hidden] {
        display: none !important;
      }

      .panel-control {
        display: flex;
        align-items: center;
        gap: 0.6rem;
      }

      .panel-control input[type="range"] {
        flex: 1;
      }

      .ghost-btn {
        border-radius: 999px;
        border: 1px solid rgba(226, 232, 240, 0.45);
        background: transparent;
        color: #e2e8f0;
        font-weight: 600;
        padding: 0.6rem 1.25rem;
        cursor: pointer;
      }

      #applyDataBtn {
        background: linear-gradient(120deg, #38bdf8, #6366f1);
        color: #0f172a;
        border: none;
        font-weight: 700;
        box-shadow: 0 12px 24px rgba(56, 189, 248, 0.35);
      }

      .controls {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        gap: 0.75rem;
      }

      .btn {
        border: none;
        border-radius: 999px;
        padding: 0.75rem 1.1rem;
        font-weight: 700;
        font-size: 1rem;
        cursor: pointer;
        color: #fff;
        background: linear-gradient(135deg, #2563eb, #3b82f6);
        box-shadow: 0 10px 18px rgba(37, 99, 235, 0.3);
      }

      .btn-secondary {
        background: transparent;
        border: 2px solid #94a3b8;
        color: #e2e8f0;
        box-shadow: none;
      }

      .stage {
        position: relative;
        width: 100%;
        border-radius: 0;
        overflow: hidden;
        background: transparent;
        box-shadow: none;
        border: none;
        --stage-aspect: 56.25%;
      }

      .stage::before {
        content: "";
        display: block;
        padding-top: var(--stage-aspect);
      }

      .stage-content {
        position: absolute;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        background: transparent;
      }

      .stage-content.exporting {
        background: transparent;
      }

      .stage-content img {
        width: 100%;
        height: 100%;
        object-fit: contain;
      }

      .stage-placeholder {
        position: absolute;
        inset: 0;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 0.35rem;
        text-align: center;
        color: #cbd5f5;
      }

      .photo-watermark {
        position: absolute;
        right: clamp(0.35rem, 3vw, 0.85rem);
        bottom: clamp(0.3rem, 2.5vw, 0.75rem);
        color: #fbbf24;
        font-size: clamp(0.65rem, 2.5vw, 0.9rem);
        letter-spacing: 0.18em;
        font-weight: 800;
        -webkit-text-stroke: 0.5px rgba(0, 0, 0, 0.9);
        text-shadow: 0 1px 3px rgba(0, 0, 0, 0.45);
        pointer-events: none;
        z-index: 5;
      }

      .whiteboard-wrapper {
        --board-scale: clamp(0.35, calc(25vw / 100), 0.45);
        --board-width: min(350px, 75%);
        position: absolute;
        left: 50%;
        top: 70%;
        transform: translate(-50%, -50%) scale(var(--board-scale)) rotate(var(--board-rotation));
        transform-origin: center;
        width: var(--board-width);
        touch-action: none;
      }

      .whiteboard {
        width: 100%;
        background: var(--board-fill);
        border-radius: 0;
        border: 4px solid var(--line-color);
        padding: 0.25rem;
        color: var(--text-color);
        box-shadow: none;
        font-weight: 700;
        font-size: calc(1rem * var(--whiteboard-font-scale, 1));
      }

      .whiteboard.exporting {
        box-shadow: none;
      }

      .whiteboard-content {
        display: flex;
        flex-direction: column;
        gap: 0;
      }

      .board-row {
        display: flex;
        align-items: center;
        gap: 0;
      }

      .board-row label {
        flex: 0 0 72px;
        font-size: 0.86rem;
        letter-spacing: 0.03em;
        color: var(--text-color);
        margin: 0;
        position: relative;
        padding-right: 0.2rem;
      }

      .board-row label::after {
        content: "：";
        position: absolute;
        right: 0;
      }

      .board-block label::after {
        content: "：";
      }

      .board-value {
        flex: 1;
        min-height: 22px;
        border: none;
        border-radius: 0;
        padding: 0 0.1rem;
        background: transparent;
        font-size: 0.96rem;
        font-weight: 600;
        color: var(--text-color);
        white-space: pre-wrap;
      }

      .board-block {
        display: grid;
        grid-template-columns: 72px 1fr;
        gap: 0.1rem;
        align-items: flex-start;
      }

      .board-block label {
        font-size: 0.88rem;
        letter-spacing: 0.04em;
        color: var(--text-color);
        position: relative;
        padding-right: 0.2rem;
      }

      .board-block label::after {
        content: "：";
        position: absolute;
        right: 0;
      }

      .board-notes {
        min-height: calc(1.2rem * 3);
        border: none;
        border-radius: 0;
        padding: 0.05rem 0.15rem;
        background: transparent;
        font-size: 1rem;
        line-height: 1.2;
        color: var(--text-color);
        white-space: pre-wrap;
      }

      .coordinate-field {
        border: 1px solid rgba(226, 232, 240, 0.35);
        border-radius: 12px;
        padding: 0.6rem 0.75rem;
        background: rgba(15, 23, 42, 0.6);
        color: #f8fafc;
        display: flex;
        flex-direction: column;
        gap: 0.25rem;
      }

      .coordinate-meta {
        font-size: 0.9rem;
        color: #cbd5f5;
      }

      .coordinate-actions {
        margin-top: 0.5rem;
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
        align-items: center;
      }

      .coordinate-actions .ghost-btn {
        padding: 0.45rem 1.2rem;
        border-radius: 999px;
        border: none;
        background: linear-gradient(120deg, #38bdf8, #6366f1);
        color: #0f172a;
        font-weight: 700;
        box-shadow: 0 10px 18px rgba(56, 189, 248, 0.35);
      }

      .coordinate-status {
        font-size: 0.85rem;
        color: #cbd5f5;
      }

      .board-coordinate {
        display: flex;
        flex-direction: column;
        gap: 0.15rem;
        width: 100%;
      }

      .board-coordinate span:first-child {
        font-size: 0.95rem;
        font-weight: 600;
      }

      .board-coordinate-meta {
        font-size: 0.9rem;
        letter-spacing: 0.03em;
      }

      .signature-placeholder-box {
        flex: 1;
        min-height: 80px;
        border: 1px dashed var(--line-color);
        border-radius: 12px;
        background: var(--board-fill);
        display: flex;
        align-items: center;
        justify-content: center;
        color: var(--text-color);
        font-size: 0.95rem;
      }

      .action-bar {
        position: fixed;
        bottom: calc(env(safe-area-inset-bottom, 0px) + 12px);
        left: 50%;
        transform: translateX(-50%);
        width: min(520px, calc(100% - 1.5rem));
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 0.75rem;
        padding: 0.85rem 1rem;
        border-radius: 24px;
        background: rgba(15, 23, 42, 0.85);
        box-shadow: 0 20px 35px rgba(0, 0, 0, 0.45);
        backdrop-filter: blur(12px);
      }

      .action-btn {
        border: none;
        border-radius: 999px;
        padding: 0.85rem 1.25rem;
        font-weight: 700;
        font-size: 1rem;
        cursor: pointer;
      }

      .action-btn.primary {
        background: linear-gradient(135deg, #059669, #10b981);
        color: #fff;
      }

      .action-btn.secondary {
        background: rgba(255, 255, 255, 0.08);
        color: #f8fafc;
        border: 1px solid rgba(255, 255, 255, 0.2);
      }

      .toast-message {
        position: fixed;
        bottom: calc(env(safe-area-inset-bottom, 0px) + 90px);
        left: 50%;
        transform: translateX(-50%);
        width: min(520px, calc(100% - 1.5rem));
        padding: 0.75rem 1rem;
        border-radius: 16px;
        background: rgba(15, 23, 42, 0.9);
        color: #f8fafc;
        text-align: center;
        font-size: 0.95rem;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.3s ease, transform 0.3s ease;
      }

      .toast-message.visible {
        opacity: 1;
        transform: translateX(-50%) translateY(-8px);
      }

      .toast-message[data-variant="success"] {
        background: rgba(34, 197, 94, 0.9);
        color: #052e13;
      }

      .hidden-input {
        display: none !important;
      }
    </style>
  </head>
  <body>
    <div class="app-shell">

      <section class="panel">
        <h3>資料輸入面板</h3>
        <div class="data-grid">
          <div class="form-field">
            <label for="inputProjectName">構造物 A</label>
            <input id="inputProjectName" type="text" placeholder="請輸入構造物 A 名稱" autocomplete="off" />
            <div class="history-dropdown" id="projectNameHistoryDropdown"></div>
          </div>
          <div class="form-field">
            <label for="inputInspectionLocation">構造物 B</label>
            <input id="inputInspectionLocation" type="text" placeholder="請輸入構造物 B 名稱" autocomplete="off" />
            <div class="history-dropdown" id="inspectionLocationHistoryDropdown"></div>
          </div>
          <div class="form-field">
            <label for="inputInspector">構造物 C</label>
            <input id="inputInspector" type="text" placeholder="請輸入構造物 C 名稱" autocomplete="off" />
            <div class="history-dropdown" id="inspectorHistoryDropdown"></div>
          </div>
          <div class="form-field" style="grid-column: 1 / -1">
            <label for="inputTestResult">其它紀錄</label>
            <textarea id="inputTestResult" placeholder="寫下其它紀錄、測量結果等" autocomplete="off"></textarea>
            <div class="history-dropdown" id="testResultHistoryDropdown"></div>
          </div>
          <div class="form-field">
            <label for="inputTestDate">檢查日期</label>
            <input id="inputTestDate" type="date" />
          </div>
          <div class="form-field" style="grid-column: 1 / -1">
            <label>現場座標</label>
            <div class="coordinate-field">
              <div id="coordinateDmsField">尚未取得</div>
              <div class="coordinate-meta" id="coordinateTwdField">X:—　Y:—</div>
            </div>
            <div class="coordinate-actions">
              <button type="button" class="ghost-btn" id="detectCoordinateBtn">取得座標</button>
              <span class="coordinate-status" id="coordinateStatus">請允許定位以自動帶入</span>
            </div>
          </div>
        </div>
        <div class="panel-hint">輸入完畢後按下「套用到白板」。</div>
        <div class="panel-actions">
          <label class="panel-control">
            <span>文字大小</span>
            <input type="range" id="fontScale" min="80" max="300" value="150" />
            <span id="fontScaleValue">150%</span>
          </label>
          <label class="panel-control">
            <span>白板寬度</span>
            <input type="range" id="boardWidth" min="240" max="640" value="350" />
            <span id="boardWidthValue">350px</span>
          </label>
          <div class="color-preset-group" role="group" aria-label="白板配色快捷">
            <button
              type="button"
              class="color-swatch"
              style="--swatch-color: #f8fafc"
              data-color-preset
              data-board-color="#f8fafc"
              data-text-color="#0f172a"
              data-line-color="#000000"
              data-board-opacity="100"
              aria-label="白色主題"
            >
              <span class="sr-only">白色主題</span>
            </button>
            <button
              type="button"
              class="color-swatch"
              style="--swatch-color: #065f46"
              data-color-preset
              data-board-color="#065f46"
              data-text-color="#f8fafc"
              data-line-color="#f8fafc"
              data-board-opacity="100"
              aria-label="綠色主題"
            >
              <span class="sr-only">綠色主題</span>
            </button>
            <button
              type="button"
              class="color-swatch"
              style="--swatch-color: rgba(15, 23, 42, 0.5)"
              data-color-preset
              data-board-color="#1f293b"
              data-text-color="#f8fafc"
              data-line-color="#f8fafc"
              data-board-opacity="85"
              aria-label="半透明灰主題"
            >
              <span class="sr-only">半透明灰主題</span>
            </button>
            <button
              type="button"
              class="color-swatch"
              style="--swatch-color: rgba(255, 255, 255, 0.8)"
              data-color-preset
              data-board-color="#f8fafc"
              data-text-color="#0f172a"
              data-line-color="#000000"
              data-board-opacity="82"
              aria-label="半透明白主題"
            >
              <span class="sr-only">半透明白主題</span>
            </button>
          </div>
          <button type="button" class="ghost-btn" id="applyDataBtn">套用到白板</button>
        </div>
        <button type="button" class="ghost-btn toggle-advanced" id="toggleAdvanced">顯示更多調整</button>
        <div class="panel-actions advanced-controls" id="advancedControls" hidden>
          <label class="panel-control">
            <span>白板尺寸</span>
            <input type="range" id="boardScale" min="10" max="120" value="45" />
            <span id="boardScaleValue">45%</span>
          </label>
          <label class="panel-control">
            <span>白板傾斜</span>
            <input type="range" id="boardRotation" min="-20" max="20" value="0" />
            <span id="boardRotationValue">0°</span>
          </label>
          <label class="panel-control">
            <span>白板顏色</span>
            <input type="color" id="boardColor" value="#f8fafc" />
          </label>
          <label class="panel-control">
            <span>透明度</span>
            <input type="range" id="boardOpacity" min="70" max="100" value="96" />
            <span id="boardOpacityValue">96%</span>
          </label>
          <label class="panel-control">
            <span>文字顏色</span>
            <input type="color" id="textColor" value="#0f172a" />
          </label>
          <label class="panel-control">
            <span>格線顏色</span>
            <input type="color" id="lineColor" value="#000000" />
          </label>
        </div>
      </section>

      <div class="controls">
        <button class="btn" id="takePhotoBtn">拍照</button>
        <button class="btn btn-secondary" id="uploadPhotoBtn">上傳照片</button>
      </div>

      <div class="stage" id="captureArea">
        <div class="stage-content" id="photoLayer">
          <img id="photoImage" alt="拍攝預覽" hidden />
          <div class="stage-placeholder" id="placeholder">
            <strong>請拍照或上傳照片</strong>
            <span>白板會顯示在畫面上，可拖曳與縮放。</span>
          </div>
        </div>
        <div class="whiteboard-wrapper" id="whiteboardWrapper">
          <div class="whiteboard" id="whiteboard">
              <div class="whiteboard-content">
              <div class="board-row">
                <label>構造物 A</label>
                <div class="board-value" id="displayProjectName">—</div>
              </div>
              <div class="board-row">
                <label>構造物 B</label>
                <div class="board-value" id="displayInspectionLocation">—</div>
              </div>
              <div class="board-row">
                <label>構造物 C</label>
                <div class="board-value" id="displayInspector">—</div>
              </div>
              <div class="board-block">
                <label>其它紀錄</label>
                <div class="board-notes" id="displayTestResult">—</div>
              </div>
              <div class="board-block">
                <label>定位座標</label>
                <div class="board-coordinate">
                  <span id="displayCoordinateDms">—</span>
                  <span class="board-coordinate-meta" id="displayCoordinateTwd">X:—　Y:—</span>
                </div>
              </div>
              <div class="board-row">
                <label>檢查日期</label>
                <div class="board-value" id="displayTestDate">—</div>
              </div>
            </div>
          </div>
        </div>
        <div class="photo-watermark" id="photoWatermark">日期未設定</div>
      </div>

      <div class="action-bar">
        <button class="action-btn secondary" id="clearBoardBtn">清除白板</button>
        <button class="action-btn primary" id="exportBtn">匯出整張圖片</button>
      </div>

      <p id="toastMessage" class="toast-message" role="status" aria-live="polite"></p>

      <input type="file" accept="image/*" capture="environment" class="hidden-input" id="takePhotoInput" />
      <input type="file" accept="image/*" class="hidden-input" id="uploadInput" />
    </div>

    <script src="https://cdn.jsdelivr.net/npm/proj4@2.9.1/dist/proj4.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/piexifjs@1.0.6/piexif.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
    <script>
      const takePhotoBtn = document.getElementById("takePhotoBtn");
      const uploadPhotoBtn = document.getElementById("uploadPhotoBtn");
      const takePhotoInput = document.getElementById("takePhotoInput");
      const uploadInput = document.getElementById("uploadInput");
      const photoLayer = document.getElementById("photoLayer");
      const photoImage = document.getElementById("photoImage");
      const placeholder = document.getElementById("placeholder");
      const whiteboardWrapper = document.getElementById("whiteboardWrapper");
      const whiteboard = document.getElementById("whiteboard");
      const captureArea = document.getElementById("captureArea");
      const boardScaleInput = document.getElementById("boardScale");
      const boardScaleValue = document.getElementById("boardScaleValue");
      const boardWidthInput = document.getElementById("boardWidth");
      const boardWidthValue = document.getElementById("boardWidthValue");
      const fontScaleInput = document.getElementById("fontScale");
      const fontScaleValue = document.getElementById("fontScaleValue");
      const boardRotationInput = document.getElementById("boardRotation");
      const boardRotationValue = document.getElementById("boardRotationValue");
      const boardColorInput = document.getElementById("boardColor");
      const boardOpacityInput = document.getElementById("boardOpacity");
      const boardOpacityValue = document.getElementById("boardOpacityValue");
      const textColorInput = document.getElementById("textColor");
      const lineColorInput = document.getElementById("lineColor");
      const colorPresetButtons = document.querySelectorAll("[data-color-preset]");
      const detectCoordinateBtn = document.getElementById("detectCoordinateBtn");
      const coordinateStatus = document.getElementById("coordinateStatus");
      const defaultCoordinateStatusText =
        coordinateStatus?.textContent || "請允許定位以自動帶入";
      const coordinateDmsField = document.getElementById("coordinateDmsField");
      const coordinateTwdField = document.getElementById("coordinateTwdField");
      const displayCoordinateDms = document.getElementById("displayCoordinateDms");
      const displayCoordinateTwd = document.getElementById("displayCoordinateTwd");
      const defaultCoordinateText = coordinateDmsField?.textContent || "尚未取得";
      const defaultTwdText = coordinateTwdField?.textContent || "X:—　Y:—";
      const applyDataBtn = document.getElementById("applyDataBtn");
      const clearBoardBtn = document.getElementById("clearBoardBtn");
      const exportBtn = document.getElementById("exportBtn");
      const toastMessage = document.getElementById("toastMessage");
      const photoWatermark = document.getElementById("photoWatermark");
      whiteboardWrapper.dataset.userPositioned = "false";
      const advancedControls = document.getElementById("advancedControls");
      const toggleAdvanced = document.getElementById("toggleAdvanced");

      const isMobileDevice = /android|iphone|ipad|ipod|mobile/i.test(
        (navigator.userAgent || "").toLowerCase()
      );
      const TWD97_PROJECTION =
        "+proj=tmerc +lat_0=0 +lon_0=121 +k=0.9999 +x_0=250000 +y_0=0 +ellps=GRS80 +units=m +no_defs";
      let lastPhotoMetadata = null;
      let lastPhotoExifBytes = null;
      const FIELD_HISTORY_STORAGE_KEY = "whiteboard_field_history_layout34";
      const FIELD_HISTORY_LIMIT = 20;

      const formInputs = {
        projectName: document.getElementById("inputProjectName"),
        inspectionLocation: document.getElementById("inputInspectionLocation"),
        testResult: document.getElementById("inputTestResult"),
        testDate: document.getElementById("inputTestDate"),
        inspector: document.getElementById("inputInspector"),
      };

      const displayTargets = {
        projectName: document.getElementById("displayProjectName"),
        inspectionLocation: document.getElementById("displayInspectionLocation"),
        testResult: document.getElementById("displayTestResult"),
        testDate: document.getElementById("displayTestDate"),
        inspector: document.getElementById("displayInspector"),
      };
      const historyDropdowns = {
        projectName: document.getElementById("projectNameHistoryDropdown"),
        inspectionLocation: document.getElementById("inspectionLocationHistoryDropdown"),
        inspector: document.getElementById("inspectorHistoryDropdown"),
        testResult: document.getElementById("testResultHistoryDropdown"),
      };

      const formatWatermarkDate = (value) => {
        if (!value) return "日期未設定";
        const [year, month, day] = value.split("-");
        if (!year || !month || !day) return value;
        return `${year}/${month}/${day}`;
      };

      const updateWatermarkDate = () => {
        if (!photoWatermark) return;
        photoWatermark.textContent = formatWatermarkDate(formInputs.testDate.value);
      };

      const formatDecimalPair = (lat, lon) => {
        if (!Number.isFinite(lat) || !Number.isFinite(lon)) return null;
        const formatValue = (value) => Number(value).toFixed(6);
        return `${formatValue(lat)}, ${formatValue(lon)}`;
      };

      const formatTwdText = (x, y) => {
        const roundedX = Math.round(x);
        const roundedY = Math.round(y);
        return `X:${roundedX}　Y:${roundedY}`;
      };

      const decimalToDmsRational = (value) => {
        const abs = Math.abs(value);
        const degrees = Math.floor(abs);
        const minutesFloat = (abs - degrees) * 60;
        const minutes = Math.floor(minutesFloat);
        const seconds = (minutesFloat - minutes) * 60;
        const toRational = (num) => [Math.round(num * 100), 100];
        return [
          [degrees, 1],
          [minutes, 1],
          toRational(seconds),
        ];
      };

      const toExifDateTime = (dateStr) =>
        `${dateStr.replace(/-/g, ":")} 00:00:00`;

      const applyExifToDataUrl = (dataUrl) => {
        if (!window.piexif) return dataUrl;
        try {
          if (lastPhotoExifBytes) {
            return piexif.insert(lastPhotoExifBytes, dataUrl);
          }
          if (!lastPhotoMetadata) return dataUrl;
          const zeroth = {};
          const exif = {};
          const gps = {};
          if (lastPhotoMetadata.date) {
            const dateTime = toExifDateTime(lastPhotoMetadata.date);
            zeroth[piexif.ImageIFD.DateTime] = dateTime;
            exif[piexif.ExifIFD.DateTimeOriginal] = dateTime;
            exif[piexif.ExifIFD.CreateDate] = dateTime;
          }
          if (lastPhotoMetadata.gps) {
            const { latitude, longitude } = lastPhotoMetadata.gps;
            gps[piexif.GPSIFD.GPSLatitudeRef] = latitude >= 0 ? "N" : "S";
            gps[piexif.GPSIFD.GPSLatitude] = decimalToDmsRational(latitude);
            gps[piexif.GPSIFD.GPSLongitudeRef] = longitude >= 0 ? "E" : "W";
            gps[piexif.GPSIFD.GPSLongitude] = decimalToDmsRational(longitude);
          }
          if (
            !Object.keys(zeroth).length &&
            !Object.keys(exif).length &&
            !Object.keys(gps).length
          ) {
            return dataUrl;
          }
          const exifBytes = piexif.dump({
            "0th": zeroth,
            Exif: exif,
            GPS: gps,
          });
          return piexif.insert(exifBytes, dataUrl);
        } catch (error) {
          console.warn("EXIF 寫入失敗", error);
          return dataUrl;
        }
      };

      const dataUrlToBlob = (dataUrl) => {
        const [header, data] = dataUrl.split(",");
        const mimeMatch = header.match(/:(.*?);/);
        const mime = mimeMatch ? mimeMatch[1] : "image/jpeg";
        const binary = atob(data);
        const array = new Uint8Array(binary.length);
        for (let i = 0; i < binary.length; i += 1) {
          array[i] = binary.charCodeAt(i);
        }
        return new Blob([array], { type: mime });
      };

      const convertToTwd97 = (lat, lon) => {
        if (typeof proj4 !== "function") {
          return null;
        }
        try {
          return proj4("EPSG:4326", TWD97_PROJECTION, [lon, lat]);
        } catch (error) {
          console.warn("TWD97 轉換失敗", error);
          return null;
        }
      };

      const updateCoordinateDisplay = (decimalText, twdText) => {
        const latLonText = decimalText || defaultCoordinateText;
        const twdDisplayText = twdText || defaultTwdText;
        coordinateDmsField.textContent = latLonText;
        coordinateTwdField.textContent = twdDisplayText;
        displayCoordinateDms.textContent = decimalText || "—";
        displayCoordinateTwd.textContent = twdDisplayText;
      };

      const resolveGeoErrorMessage = (error) => {
        if (!error) return "定位失敗，請稍後再試。";
        switch (error.code) {
          case error.PERMISSION_DENIED:
            return "定位權限被拒絕，請開啟定位權限。";
          case error.POSITION_UNAVAILABLE:
            return "目前無法取得位置資訊。";
          case error.TIMEOUT:
            return "定位逾時，請移動到訊號較佳的位置。";
          default:
            return "定位失敗，請稍後再試。";
        }
      };

      const detectCoordinates = () => {
        if (!navigator.geolocation) {
          const message = "此裝置不支援定位功能。";
          coordinateStatus.textContent = message;
          showToast(message);
          return;
        }
        coordinateStatus.textContent = "定位中…";
        detectCoordinateBtn.disabled = true;
        navigator.geolocation.getCurrentPosition(
          (position) => {
            const { latitude, longitude } = position.coords;
            const decimalText = formatDecimalPair(latitude, longitude);
            const twd = convertToTwd97(latitude, longitude);
            const twdText = twd ? formatTwdText(twd[0], twd[1]) : defaultTwdText;
            updateCoordinateDisplay(decimalText, twdText);
            coordinateStatus.textContent = "定位成功";
            showToast("已更新座標資訊。", "success");
            detectCoordinateBtn.disabled = false;
          },
          (error) => {
            const message = resolveGeoErrorMessage(error);
            coordinateStatus.textContent = message;
            showToast(message);
            detectCoordinateBtn.disabled = false;
          },
          { enableHighAccuracy: true, timeout: 15000 }
        );
      };

      const readFieldHistoryStore = () => {
        try {
          let raw = localStorage.getItem(FIELD_HISTORY_STORAGE_KEY);
          if (!raw) {
            const legacyRaw = localStorage.getItem("whiteboard_field_history_v1");
            if (legacyRaw) {
              localStorage.setItem(FIELD_HISTORY_STORAGE_KEY, legacyRaw);
              raw = legacyRaw;
            }
          }
          const parsed = raw ? JSON.parse(raw) : {};
          return typeof parsed === "object" && parsed ? parsed : {};
        } catch (error) {
          console.warn("讀取歷史資料失敗", error);
          return {};
        }
      };

      let fieldHistory = readFieldHistoryStore();

      const writeFieldHistoryStore = () => {
        try {
          localStorage.setItem(FIELD_HISTORY_STORAGE_KEY, JSON.stringify(fieldHistory));
        } catch (error) {
          console.warn("儲存歷史資料失敗", error);
        }
      };

      const getFieldHistory = (field) => {
        const list = fieldHistory[field];
        return Array.isArray(list) ? list : [];
      };

      const renderHistoryDropdown = (field) => {
        const dropdown = historyDropdowns[field];
        if (!dropdown) return false;
        dropdown.innerHTML = "";
        const history = getFieldHistory(field);
        if (!history.length) return false;
        history.forEach((item) => {
          const button = document.createElement("button");
          button.type = "button";
          button.textContent = item;
          button.addEventListener("mousedown", (event) => {
            event.preventDefault();
            const targetInput = formInputs[field];
            if (!targetInput) return;
            targetInput.value = item;
            if (field === "testResult") {
              autoResizeTextarea(targetInput);
            }
            syncField(field);
            hideFieldHistory(field);
          });
          dropdown.appendChild(button);
        });
        return true;
      };

      const updateDropdownContent = (field) => {
        const dropdown = historyDropdowns[field];
        if (!dropdown) return;
        const wasVisible = dropdown.classList.contains("is-visible");
        const hasItems = renderHistoryDropdown(field);
        if (wasVisible && hasItems) {
          dropdown.classList.add("is-visible");
        } else if (!hasItems) {
          dropdown.classList.remove("is-visible");
        }
      };

      const saveFieldHistory = (field, value) => {
        const trimmed = (value || "").trim();
        if (!trimmed) return;
        const current = getFieldHistory(field).filter((item) => item !== trimmed);
        current.unshift(trimmed);
        fieldHistory[field] = current.slice(0, FIELD_HISTORY_LIMIT);
        writeFieldHistoryStore();
        updateDropdownContent(field);
      };

      const refreshAllFieldHistoryUI = () => {
        Object.keys(historyDropdowns).forEach((field) => {
          renderHistoryDropdown(field);
          hideFieldHistory(field);
        });
      };

      const historyDropdownHideTimers = {};

      const showFieldHistory = (field) => {
        const dropdown = historyDropdowns[field];
        if (!dropdown) return;
        clearTimeout(historyDropdownHideTimers[field]);
        const hasItems = renderHistoryDropdown(field);
        if (hasItems) {
          dropdown.classList.add("is-visible");
        }
      };

      const hideFieldHistory = (field) => {
        const dropdown = historyDropdowns[field];
        if (!dropdown) return;
        dropdown.classList.remove("is-visible");
      };

      const scheduleHideFieldHistory = (field) => {
        clearTimeout(historyDropdownHideTimers[field]);
        historyDropdownHideTimers[field] = setTimeout(() => hideFieldHistory(field), 120);
      };

      const formatDateInputValue = (date) => {
        if (!(date instanceof Date) || Number.isNaN(date.getTime())) return "";
        const month = String(date.getMonth() + 1).padStart(2, "0");
        const day = String(date.getDate()).padStart(2, "0");
        return `${date.getFullYear()}-${month}-${day}`;
      };

      const readFileAsDataURL = (file) =>
        new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = () => resolve(reader.result);
          reader.onerror = () => reject(new Error("failed to load file"));
          reader.readAsDataURL(file);
        });

      const asciiFromView = (view, start, length) => {
        let chars = "";
        for (let i = 0; i < length && start + i < view.byteLength; i += 1) {
          const code = view.getUint8(start + i);
          if (!code) break;
          chars += String.fromCharCode(code);
        }
        return chars.trim();
      };

      const normalizeExifDate = (value) => {
        if (!value) return null;
        const match = value.match(/^(\d{4}):?(\d{2}):?(\d{2})/);
        if (!match) return null;
        const [, year, month, day] = match;
        return `${year}-${month}-${day}`;
      };

      const TYPE_SIZES = {
        1: 1,
        2: 1,
        3: 2,
        4: 4,
        5: 8,
        7: 1,
      };

      const EXIF_DATE_TAGS = new Set([0x0132, 0x9003, 0x9004]);

      const GPS_TAGS = {
        LAT_REF: 0x0001,
        LAT: 0x0002,
        LON_REF: 0x0003,
        LON: 0x0004,
      };

      const readRationalArray = (view, offset, little, count) => {
        const result = [];
        for (let i = 0; i < count; i += 1) {
          const numerator = view.getUint32(offset + i * 8, little);
          const denominator = view.getUint32(offset + i * 8 + 4, little) || 1;
          result.push(numerator / denominator);
        }
        return result;
      };

      const convertGpsValuesToDecimal = (values, ref) => {
        if (!values || values.length < 3) return null;
        const decimal = values[0] + values[1] / 60 + values[2] / 3600;
        if (!ref) return decimal;
        const normalizedRef = ref.trim().toUpperCase();
        if (normalizedRef === "S" || normalizedRef === "W") {
          return -decimal;
        }
        return decimal;
      };

      const parseGpsIfd = (view, offset, base, little) => {
        if (offset <= 0 || offset + 2 > view.byteLength) return null;
        const entryCount = view.getUint16(offset, little);
        let latRef = null;
        let lonRef = null;
        let latValues = null;
        let lonValues = null;
        for (let i = 0; i < entryCount; i += 1) {
          const entryOffset = offset + 2 + i * 12;
          if (entryOffset + 12 > view.byteLength) break;
          const tag = view.getUint16(entryOffset, little);
          const type = view.getUint16(entryOffset + 2, little);
          const count = view.getUint32(entryOffset + 4, little);
          const valueSize = (TYPE_SIZES[type] || 0) * count;
          const rawValueOffset = entryOffset + 8;
          let valueOffset = rawValueOffset;
          if (valueSize > 4) {
            valueOffset = base + view.getUint32(rawValueOffset, little);
          }
          if (tag === GPS_TAGS.LAT_REF && type === 2) {
            latRef = asciiFromView(view, valueOffset, Math.min(count, 2));
          } else if (tag === GPS_TAGS.LON_REF && type === 2) {
            lonRef = asciiFromView(view, valueOffset, Math.min(count, 2));
          } else if (tag === GPS_TAGS.LAT && type === 5 && count >= 3) {
            latValues = readRationalArray(view, valueOffset, little, 3);
          } else if (tag === GPS_TAGS.LON && type === 5 && count >= 3) {
            lonValues = readRationalArray(view, valueOffset, little, 3);
          }
        }
        if (!latValues || !lonValues) return null;
        const latitude = convertGpsValuesToDecimal(latValues, latRef);
        const longitude = convertGpsValuesToDecimal(lonValues, lonRef);
        if (
          typeof latitude !== "number" ||
          Number.isNaN(latitude) ||
          typeof longitude !== "number" ||
          Number.isNaN(longitude)
        ) {
          return null;
        }
        return { latitude, longitude };
      };

      const parseIfdForMetadata = (view, offset, base, little, metadata = {}) => {
        if (offset <= 0 || offset + 2 > view.byteLength) return metadata;
        const entryCount = view.getUint16(offset, little);
        for (let i = 0; i < entryCount; i += 1) {
          const entryOffset = offset + 2 + i * 12;
          if (entryOffset + 12 > view.byteLength) break;
          const tag = view.getUint16(entryOffset, little);
          const type = view.getUint16(entryOffset + 2, little);
          const count = view.getUint32(entryOffset + 4, little);
          const valueSize = (TYPE_SIZES[type] || 0) * count;
          const rawValueOffset = entryOffset + 8;
          let valueOffset = rawValueOffset;
          if (valueSize > 4) {
            valueOffset = base + view.getUint32(rawValueOffset, little);
          }
          if (tag === 0x8769) {
            const pointer = base + view.getUint32(rawValueOffset, little);
            parseIfdForMetadata(view, pointer, base, little, metadata);
            continue;
          }
          if (tag === 0x0112 && type === 3 && count >= 1) {
            const orientation =
              valueSize > 2
                ? view.getUint16(valueOffset, little)
                : view.getUint16(rawValueOffset, little);
            if (orientation) {
              metadata.orientation = orientation;
            }
            continue;
          }
          if (tag === 0x8825) {
            const pointer = base + view.getUint32(rawValueOffset, little);
            const gps = parseGpsIfd(view, pointer, base, little);
            if (gps) {
              metadata.gps = gps;
            }
            continue;
          }
          if (EXIF_DATE_TAGS.has(tag) && type === 2 && count > 0) {
            const raw = asciiFromView(view, valueOffset, count);
            const normalized = normalizeExifDate(raw);
            if (normalized) {
              if (tag === 0x9003) {
                metadata.primaryDate = normalized;
              } else if (!metadata.fallbackDate) {
                metadata.fallbackDate = normalized;
              }
            }
          }
        }
        return metadata;
      };

      const readExifMetadataFromBuffer = (buffer) => {
        const view = new DataView(buffer);
        if (view.byteLength < 12 || view.getUint16(0, false) !== 0xffd8) return {};
        let offset = 2;
        while (offset + 4 < view.byteLength) {
          if (view.getUint8(offset) !== 0xff) break;
          const marker = view.getUint8(offset + 1);
          const length = view.getUint16(offset + 2, false);
          if (marker === 0xe1) {
            const segmentStart = offset + 4;
            const identifier = asciiFromView(view, segmentStart, 4);
            if (identifier !== "Exif") {
              offset += 2 + length;
              continue;
            }
            const tiffStart = segmentStart + 6;
            if (tiffStart + 8 > view.byteLength) break;
            const little = view.getUint16(tiffStart, false) === 0x4949;
            const firstIfdOffset = view.getUint32(tiffStart + 4, little);
            const metadata = parseIfdForMetadata(
              view,
              tiffStart + firstIfdOffset,
              tiffStart,
              little,
              {}
            );
            return {
              date: metadata.primaryDate || metadata.fallbackDate || null,
              gps: metadata.gps || null,
            };
          }
          offset += 2 + length;
        }
        return {};
      };

      const extractExifMetadata = async (file) => {
        if (!file || !/image\/jpe?g/i.test(file.type || "")) return {};
        try {
          const buffer = await file.arrayBuffer();
          return readExifMetadataFromBuffer(buffer) || {};
        } catch (error) {
          console.warn("EXIF 解析失敗", error);
          return {};
        }
      };

      const applyPhotoMetadata = async (file, dataUrl) => {
        if (!file) return;
        let metadata = {};
        try {
          metadata = await extractExifMetadata(file);
        } catch (error) {
          console.warn("讀取 EXIF 資料失敗", error);
        }
        lastPhotoMetadata =
          metadata && (metadata.date || metadata.gps || metadata.orientation)
            ? { ...metadata }
            : null;
        if (window.piexif && dataUrl) {
          try {
            const exifObj = piexif.load(dataUrl);
            if (exifObj["0th"]) {
              delete exifObj["0th"][piexif.ImageIFD.Orientation];
            }
            lastPhotoExifBytes = piexif.dump(exifObj);
          } catch (error) {
            console.warn("EXIF 載入失敗", error);
            lastPhotoExifBytes = null;
          }
        } else {
          lastPhotoExifBytes = null;
        }
        if (lastPhotoMetadata?.orientation) {
          delete lastPhotoMetadata.orientation;
        }
        const exifDate = metadata.date;
        const usedExif = Boolean(exifDate);
        let resolvedDate = exifDate;
        if (!resolvedDate) {
          resolvedDate =
            file.lastModified && Number.isFinite(file.lastModified)
              ? formatDateInputValue(new Date(file.lastModified))
              : formatDateInputValue(new Date());
        }

        formInputs.testDate.value = resolvedDate;
        syncField("testDate");

        let toastMessageContent = usedExif
          ? "已套用照片拍攝日期，如需修改可手動調整"
          : "已套用拍攝日期，如需修改可手動調整";

        if (metadata.gps) {
          const { latitude, longitude } = metadata.gps;
          const decimalText = formatDecimalPair(latitude, longitude);
          const twd = convertToTwd97(latitude, longitude);
          const twdText = twd ? formatTwdText(twd[0], twd[1]) : defaultTwdText;
          updateCoordinateDisplay(decimalText, twdText);
          coordinateStatus.textContent = "已套用照片座標";
          toastMessageContent += "；已套用照片座標";
        } else {
          coordinateStatus.textContent = defaultCoordinateStatusText;
        }

        showToast(`${toastMessageContent}。`, "success");
      };

      const autoResizeTextarea = (textarea) => {
        if (!textarea) return;
        textarea.style.height = "auto";
        textarea.style.height = `${Math.min(textarea.scrollHeight, 600)}px`;
      };

      const showToast = (message, variant = "info") => {
        toastMessage.textContent = message;
        toastMessage.dataset.variant = variant;
        toastMessage.classList.add("visible");
        clearTimeout(showToast.timer);
        showToast.timer = setTimeout(
          () => toastMessage.classList.remove("visible"),
          4500
        );
      };

      const updateStageAspect = () => {
        if (photoImage.hidden || !photoImage.naturalWidth) {
          captureArea.style.setProperty("--stage-aspect", "56.25%");
          requestAnimationFrame(positionBoardAtBottomLeft);
          return;
        }
        const ratio = (photoImage.naturalHeight / photoImage.naturalWidth) * 100;
        captureArea.style.setProperty("--stage-aspect", `${ratio}%`);
        requestAnimationFrame(positionBoardAtBottomLeft);
      };

      const handlePhotoFiles = async (files) => {
        const [file] = files || [];
        if (!file) return;
        let dataUrl = null;
        try {
          dataUrl = await readFileAsDataURL(file);
          photoImage.src = dataUrl;
          photoImage.hidden = false;
          placeholder.style.display = "none";
          updateStageAspect();
          whiteboardWrapper.dataset.userPositioned = "false";
          requestAnimationFrame(positionBoardAtBottomLeft);
        } catch (error) {
          showToast("照片載入失敗，請重新選擇。");
          return;
        }
        await applyPhotoMetadata(file, dataUrl);
      };

      const clamp = (value, min, max) => Math.min(Math.max(value, min), max);

      const startDrag = (event) => {
        if (event.target.closest("input, textarea, button, select")) return;
        whiteboardWrapper.dataset.dragging = "true";
        whiteboardWrapper.dataset.userPositioned = "true";
        const rect = whiteboardWrapper.getBoundingClientRect();
        whiteboardWrapper.dataset.offsetX =
          (event.clientX ?? event.touches?.[0]?.clientX ?? 0) - rect.left;
        whiteboardWrapper.dataset.offsetY =
          (event.clientY ?? event.touches?.[0]?.clientY ?? 0) - rect.top;
        whiteboardWrapper.dataset.stageRect = JSON.stringify(
          captureArea.getBoundingClientRect()
        );
      };

      const dragMove = (event) => {
        if (whiteboardWrapper.dataset.dragging !== "true") return;
        event.preventDefault();
        const stageRect = JSON.parse(whiteboardWrapper.dataset.stageRect);
        const boardRect = whiteboardWrapper.getBoundingClientRect();
        const offsetX = parseFloat(whiteboardWrapper.dataset.offsetX);
        const offsetY = parseFloat(whiteboardWrapper.dataset.offsetY);
        const pointerX = event.clientX ?? event.touches?.[0]?.clientX ?? 0;
        const pointerY = event.clientY ?? event.touches?.[0]?.clientY ?? 0;
        const newLeft = clamp(
          pointerX - stageRect.left - offsetX + boardRect.width / 2,
          boardRect.width / 2,
          stageRect.width - boardRect.width / 2
        );
        const newTop = clamp(
          pointerY - stageRect.top - offsetY + boardRect.height / 2,
          boardRect.height / 2,
          stageRect.height - boardRect.height / 2
        );
        whiteboardWrapper.style.left = `${(newLeft / stageRect.width) * 100}%`;
        whiteboardWrapper.style.top = `${(newTop / stageRect.height) * 100}%`;
      };

      const endDrag = () => {
        whiteboardWrapper.dataset.dragging = "false";
      };

      const positionBoardAtBottomLeft = () => {
        if (whiteboardWrapper.dataset.userPositioned === "true") return;
        const stageRect = captureArea.getBoundingClientRect();
        if (!stageRect.width || !stageRect.height) return;
        const boardRect = whiteboardWrapper.getBoundingClientRect();
        if (!boardRect.width || !boardRect.height) return;
        const photoRect =
          !photoImage.hidden && photoImage.naturalWidth
            ? photoImage.getBoundingClientRect()
            : stageRect;
        const paddingX = Math.max(8, stageRect.width * 0.012);
        const paddingY = Math.max(8, stageRect.height * 0.012);
        const leftEdge = Math.max(photoRect.left, stageRect.left) + paddingX;
        const bottomEdge = Math.min(photoRect.bottom, stageRect.bottom) - paddingY;
        const centerX = clamp(
          leftEdge - stageRect.left + boardRect.width / 2,
          boardRect.width / 2,
          stageRect.width - boardRect.width / 2
        );
        const centerY = clamp(
          bottomEdge - stageRect.top - boardRect.height / 2,
          boardRect.height / 2,
          stageRect.height - boardRect.height / 2
        );
        whiteboardWrapper.style.left = `${(centerX / stageRect.width) * 100}%`;
        whiteboardWrapper.style.top = `${(centerY / stageRect.height) * 100}%`;
      };

      let baseBoardScale = Number(boardScaleInput.value) / 100;
      let fontScaleFactor = Number(fontScaleInput.value) / 100;

      const applyScale = () => {
        const combinedScale = baseBoardScale * fontScaleFactor;
        whiteboardWrapper.style.setProperty("--board-scale", combinedScale.toString());
        document.documentElement.style.setProperty("--whiteboard-font-scale", fontScaleFactor.toString());
      };

      const updateBoardScale = (value) => {
        const percent = Math.max(10, Math.min(120, Number(value)));
        baseBoardScale = percent / 100;
        boardScaleValue.textContent = `${percent}%`;
        applyScale();
        if (whiteboardWrapper.dataset.userPositioned !== "true") {
          requestAnimationFrame(positionBoardAtBottomLeft);
        }
      };

      const updateFontScale = (value) => {
        const percent = Math.max(50, Math.min(300, Number(value)));
        fontScaleFactor = percent / 100;
        fontScaleValue.textContent = `${percent}%`;
        applyScale();
        if (whiteboardWrapper.dataset.userPositioned !== "true") {
          requestAnimationFrame(positionBoardAtBottomLeft);
        }
      };

      const updateBoardWidth = (value) => {
        const width = Math.max(200, Math.min(800, Number(value)));
        const clamped = Math.round(width);
        whiteboardWrapper.style.setProperty("--board-width", `${clamped}px`);
        boardWidthValue.textContent = `${clamped}px`;
        if (whiteboardWrapper.dataset.userPositioned !== "true") {
          requestAnimationFrame(positionBoardAtBottomLeft);
        }
      };

      const toggleExportAppearance = (enable) => {
        const state = Boolean(enable);
        captureArea.classList.toggle("exporting", state);
        photoLayer.classList.toggle("exporting", state);
        whiteboard.classList.toggle("exporting", state);
      };

      function syncField(key) {
        const value = formInputs[key].value.trim();
        displayTargets[key].textContent = value || "—";
        if (key === "testDate") {
          updateWatermarkDate();
        }
      }

      const syncAllFields = () => Object.keys(formInputs).forEach(syncField);

      const clearBoard = () => {
        Object.values(formInputs).forEach((input) => (input.value = ""));
        formInputs.testDate.valueAsDate = new Date();
        syncAllFields();
        lastPhotoMetadata = null;
        lastPhotoExifBytes = null;
        updateCoordinateDisplay();
        coordinateStatus.textContent = defaultCoordinateStatusText;
      };

      const updateBoardColor = (color) => {
        document.documentElement.style.setProperty("--board-fill", color);
      };

      const updateBoardRotation = (value) => {
        const angle = Math.max(-90, Math.min(90, Number(value)));
        document.documentElement.style.setProperty("--board-rotation", `${angle}deg`);
        boardRotationValue.textContent = `${angle}°`;
      };

      const updateBoardOpacity = (percent) => {
        const value = Math.max(30, Math.min(100, Number(percent)));
        whiteboard.style.opacity = (value / 100).toString();
        boardOpacityValue.textContent = `${value}%`;
      };

      const updateTextColor = (color) => {
        document.documentElement.style.setProperty("--text-color", color);
      };

      const updateLineColor = (color) => {
        document.documentElement.style.setProperty("--line-color", color);
      };

      const applyColorPreset = (button) => {
        if (!button?.dataset) return;
        const { boardColor, textColor, lineColor, boardOpacity } = button.dataset;
        if (boardColor) {
          boardColorInput.value = boardColor;
          updateBoardColor(boardColor);
        }
        if (textColor) {
          textColorInput.value = textColor;
          updateTextColor(textColor);
        }
        if (lineColor) {
          lineColorInput.value = lineColor;
          updateLineColor(lineColor);
        }
        if (boardOpacity) {
          boardOpacityInput.value = boardOpacity;
          updateBoardOpacity(boardOpacity);
        }
        showToast("已套用預設配色。", "success");
      };

      const toggleWhiteboardSolid = (enable) => {
        whiteboard.classList.toggle("solid-mode", Boolean(enable));
      };

      const downloadBlob = (blob, filename) => {
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.href = url;
        link.download = filename;
        link.click();
        setTimeout(() => URL.revokeObjectURL(url), 2000);
      };

      const buildShareText = () => {
        const sections = [
          { label: "構造物 A", value: displayTargets.projectName.textContent },
          { label: "構造物 B", value: displayTargets.inspectionLocation.textContent },
          { label: "構造物 C", value: displayTargets.inspector.textContent },
          { label: "其它紀錄", value: displayTargets.testResult.textContent },
          { label: "檢查日期", value: displayTargets.testDate.textContent },
        ];
        return sections.map((item) => `${item.label}：${item.value || "—"}`).join("\n");
      };

      const handleShareOrDownload = async (blob, filename) => {
        const file = new File([blob], filename, { type: "image/jpeg" });
        const shareText = buildShareText();
        if (
          isMobileDevice &&
          navigator.canShare &&
          navigator.canShare({ files: [file] }) &&
          navigator.share
        ) {
          try {
            await navigator.share({
              files: [file],
              title: "構造物白板照片",
              text: shareText,
            });
            showToast("已開啟分享面板，請選擇儲存影像。", "success");
            return;
          } catch (error) {
            if (error.name !== "AbortError") {
              showToast("分享面板不可用，將自動下載影像。");
            }
          }
        }
        downloadBlob(blob, filename);
        showToast("已下載圖片，可直接選擇儲存位置。", "success");
      };

      const exportBoardImage = async () => {
        exportBtn.disabled = true;
        exportBtn.textContent = "匯出中…";
        toggleExportAppearance(true);
        toggleWhiteboardSolid(true);
        try {
          const canvas = await html2canvas(captureArea, {
            backgroundColor: null,
            scale: window.devicePixelRatio || 2,
          });
          let dataUrl = canvas.toDataURL("image/jpeg", 0.92);
          dataUrl = applyExifToDataUrl(dataUrl);
          const blob = dataUrlToBlob(dataUrl);
          const timestamp = new Date().toISOString().replace(/[T:]/g, "-").split(".")[0];
          await handleShareOrDownload(blob, `whiteboard_${timestamp}.jpg`);
        } catch (error) {
          console.error(error);
          showToast("匯出失敗，請再試一次。");
        } finally {
          toggleExportAppearance(false);
          toggleWhiteboardSolid(false);
          exportBtn.disabled = false;
          exportBtn.textContent = "匯出整張圖片";
        }
      };

      takePhotoBtn.addEventListener("click", () => takePhotoInput.click());
      uploadPhotoBtn.addEventListener("click", () => uploadInput.click());
      takePhotoInput.addEventListener("change", (event) => handlePhotoFiles(event.target.files));
      uploadInput.addEventListener("change", (event) => handlePhotoFiles(event.target.files));

      whiteboardWrapper.addEventListener("pointerdown", startDrag);
      window.addEventListener("pointermove", dragMove, { passive: false });
      window.addEventListener("pointerup", endDrag);
      window.addEventListener("pointercancel", endDrag);

      const historyFields = ["projectName", "inspectionLocation", "inspector", "testResult"];
      const historyTextFields = ["projectName", "inspectionLocation", "inspector"];

      applyDataBtn.addEventListener("click", () => {
        syncAllFields();
        historyFields.forEach((field) => saveFieldHistory(field, formInputs[field].value));
        showToast("白板內容已更新。", "success");
      });

      clearBoardBtn.addEventListener("click", () => {
        clearBoard();
        showToast("白板文字已清除。", "success");
      });

      boardScaleInput.addEventListener("input", (event) =>
        updateBoardScale(event.target.value)
      );
      boardWidthInput.addEventListener("input", (event) =>
        updateBoardWidth(event.target.value)
      );
      boardRotationInput.addEventListener("input", (event) =>
        updateBoardRotation(event.target.value)
      );
      fontScaleInput.addEventListener("input", (event) =>
        updateFontScale(event.target.value)
      );
      boardColorInput.addEventListener("input", (event) =>
        updateBoardColor(event.target.value)
      );
      boardOpacityInput.addEventListener("input", (event) =>
        updateBoardOpacity(event.target.value)
      );
      textColorInput.addEventListener("input", (event) =>
        updateTextColor(event.target.value)
      );
      lineColorInput.addEventListener("input", (event) =>
        updateLineColor(event.target.value)
      );
      colorPresetButtons.forEach((button) =>
        button.addEventListener("click", () => applyColorPreset(button))
      );
      refreshAllFieldHistoryUI();

      historyTextFields.forEach((field) => {
        const input = formInputs[field];
        if (!input) return;
        input.addEventListener("focus", () => showFieldHistory(field));
        input.addEventListener("input", () => showFieldHistory(field));
        input.addEventListener("blur", () => scheduleHideFieldHistory(field));
      });

      formInputs.testResult.addEventListener("focus", () => showFieldHistory("testResult"));
      formInputs.testResult.addEventListener("blur", () => scheduleHideFieldHistory("testResult"));
      detectCoordinateBtn.addEventListener("click", detectCoordinates);

      exportBtn.addEventListener("click", exportBoardImage);
      window.addEventListener("resize", updateStageAspect);
      photoImage.addEventListener("load", updateStageAspect);

      if (isMobileDevice) {
        boardScaleInput.value = "35";
        boardScaleValue.textContent = "35%";
        boardWidthInput.value = "320";
        boardWidthValue.textContent = "320px";
        fontScaleInput.value = "130";
        fontScaleValue.textContent = "130%";
      }
      if (!formInputs.testDate.value) {
        formInputs.testDate.valueAsDate = new Date();
      }
      syncAllFields();
      updateBoardScale(boardScaleInput.value);
      updateFontScale(fontScaleInput.value);
      updateBoardWidth(boardWidthInput.value);
      updateBoardRotation(boardRotationInput.value);
      updateBoardColor(boardColorInput.value);
      updateBoardOpacity(boardOpacityInput.value);
      updateTextColor(textColorInput.value);
      updateLineColor(lineColorInput.value);
      updateCoordinateDisplay();
      updateWatermarkDate();
      requestAnimationFrame(positionBoardAtBottomLeft);

      toggleAdvanced.addEventListener("click", () => {
        const isHidden = advancedControls.hasAttribute("hidden");
        if (isHidden) {
          advancedControls.removeAttribute("hidden");
          toggleAdvanced.textContent = "隱藏更多調整";
        } else {
          advancedControls.setAttribute("hidden", "true");
          toggleAdvanced.textContent = "顯示更多調整";
        }
      });
      autoResizeTextarea(formInputs.testResult);
      formInputs.testResult.addEventListener("input", () => {
        autoResizeTextarea(formInputs.testResult);
        showFieldHistory("testResult");
      });
      formInputs.testDate.addEventListener("change", () =>
        syncField("testDate")
      );
    </script>
  </body>
</html>
